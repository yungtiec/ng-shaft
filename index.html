<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - geometry - cube</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                margin: 0px;
                background-color: #000000;
                overflow: hidden;
            }
        </style>
    </head>
    <body>

        <script src="src/three.js"></script>

        <script>

            var camera, scene, renderer;
            var mesh;
            var shafts = [];
            var shaftSpeed = 3;
            var player;
            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2();

            init();
            animate();

            function init() {
                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                //
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
                camera.position.z = 400;

                scene = new THREE.Scene();

                var texture = new THREE.TextureLoader().load( 'src/crate.gif' );

                var geometry = new THREE.BoxBufferGeometry( 100, 20, 100 );
                var cubeGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
                var material = new THREE.MeshBasicMaterial( { map: texture } );

                var radius = 500;
                var nBoxes = 50;
                for (var i = 0; i < nBoxes; i++) {
                    var mesh = new THREE.Mesh( geometry, material );
                    mesh.position.set( radius/2 - radius * Math.random(),
                                       radius/2 - radius * Math.random(),
                                       radius/2 - radius * Math.random() );
                    scene.add(mesh);
                    shafts.push(mesh);
                }

                player = new THREE.Mesh( cubeGeometry, new THREE.MeshBasicMaterial() );
                scene.add(player);

                renderer.domElement.addEventListener( 'mousemove', onMouseMove, false );
                // renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
                // renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function onMouseMove ( event ) {

                // calculate mouse position in normalized device coordinates
                // (-1 to +1) for both components

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

            }


            function animate() {
                // where all the action is

                requestAnimationFrame( animate );

                // prevent shafts from falling out of the screen
                for (var i = 0; i < shafts.length; i++) {
                    if (shafts[i].position.y < -250) {
                        shafts[i].position.y = 250;
                    } else {
                        shafts[i].position.y -= shaftSpeed;
                    }
                }

                var intersects = raycaster.intersectObjects( player );

                for ( var i = 0; i < intersects.length; i++ ) {

                    intersects[ i ].object.material.color.set( 0xff0000 );

                }

                renderer.render( scene, camera );

            }

        </script>

    </body>
</html>
