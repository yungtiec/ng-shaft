<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:800' rel='stylesheet' type='text/css'>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ngStorage/0.3.6/ngStorage.min.js"></script>
    <script type="text/javascript" src="light.js"></script>
    <style>
    body {
        margin: 0px;
        background: #69ceec;
        overflow: hidden;
        font-family: 'Open Sans', sans-serif;
    }

    ul {
        list-style: none;
        padding: 0;
    }

    li {
        display: flex;
        justify-content: space-around;
        margin: 5px 0;
    }

    p {
        color: white;
        margin: 8px;
    }

    span {
        margin: 0 75px;
        font-size: 1.3em;
    }

    #world {
        margin: 0px;
        background: #69ceec;
        overflow: hidden;
    }

    #dashboard {
        position: absolute;
    }

    #level {
        font-size: 30px;
    }

    #play {
        position: absolute;
        width: 500px;
        height: 200px;
        background-color: gray;
        opacity: 0.75;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
    }

    #gameover {
        position: absolute;
        width: 500px;
        height: 200px;
        background-color: gray;
        opacity: 0.75;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
    }

    #logo {
        position: relative;
        top: 60px;
        color: #ef7c91;
        font-size: 1.2em;
        -webkit-text-shadow: 0px 3px 0px #ec4141;
        -moz-text-shadow: 0px 3px 0px #ec4141;
        text-shadow: 0px 3px 0px #ec4141;
    }

    .scoreboard {
        color: #ef7c91;
        position: absolute;
        top: 29%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.2em;
        -webkit-text-shadow: 0px 3px 0px #ec4141;
        -moz-text-shadow: 0px 3px 0px #ec4141;
        text-shadow: 0px 3px 0px #ec4141;
    }

    button[name=start] {
        font-family: 'Open Sans', sans-serif;
        position: absolute;
        top: 200%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 1.2em;
        width: 280px;
        color: #FFF;
        display: block;
        text-decoration: none;
        margin: 0 auto;
        border: solid 1px #f79472;
        background: #f79472;
        text-align: center;
        padding: 10px 30px;
        -webkit-transition: all 0.1s;
        -moz-transition: all 0.1s;
        transition: all 0.1s;
        -webkit-box-shadow: 0px 9px 0px #e6805c;
        -moz-box-shadow: 0px 9px 0px #e6805c;
        box-shadow: 0px 9px 0px #e6805c;
    }

    button[name=start]:active {
        -webkit-box-shadow: 0px 2px 0px #e6805c;
        -moz-box-shadow: 0px 2px 0px #e6805c;
        box-shadow: 0px 2px 0px #e6805c;
    }

    button[name=start]:focus {
        outline:0;
    }

    button[name=restart] {
        font-family: 'Open Sans', sans-serif;
        position: absolute;
        top: 75%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 1.2em;
        width: 380px;
        color: #FFF;
        display: block;
        text-decoration: none;
        margin: 0 auto;
        border: solid 1px #f79472;
        background: #f79472;
        text-align: center;
        padding: 10px 30px;
        -webkit-transition: all 0.1s;
        -moz-transition: all 0.1s;
        transition: all 0.1s;
        -webkit-box-shadow: 0px 9px 0px #e6805c;
        -moz-box-shadow: 0px 9px 0px #e6805c;
        box-shadow: 0px 9px 0px #e6805c;
    }

    button[name=restart]:active {
        -webkit-box-shadow: 0px 2px 0px #e6805c;
        -moz-box-shadow: 0px 2px 0px #e6805c;
        box-shadow: 0px 2px 0px #e6805c;
    }

    button[name=restart]:focus {
        outline:0;
    }
    </style>
</head>

<body ng-app="threeDShaft" ng-controller="threeDShaft">
    <div id="world">
        <div id="dashboard" ng-hide="gameOver || !playing">
            <p id="level">地下第 {{ level }} 階</p>
            <p id="score">分數: {{ score }} </p>
            <p id="life">生命值: {{ lives }}</p>
        </div>
        <button name="restart" ng-show="gameOver" ng-click="restart()">TRY AGAIN</button>
        <ul class="scoreboard" ng-show="gameOver">
            <li>YOUR BEST SCORES</li>
            <li ng-repeat="score in $storage.bestScores track by $index">
                <span>{{score}}</span>
            </li>
        </ul>
        <div ng-hide="playing" class="scoreboard">
            <p id="logo">
                小朋友下樓梯 3D版
                <br>
                <button name="start" ng-click="start()">PLAY</button>
            </p>
        </div>
    </div>
    <script src="src/three.js"></script>
    <script>
    var app = angular.module('threeDShaft', ['ngStorage']);
    app.controller('threeDShaft', function($scope, $interval, $localStorage) {

        var camera, scene, renderer;
        var items = [];
        var shaftSpeed = 3;
        var rotSpeed = 0.2;
        var shaftHeight = 20;

        var upKeyDown = false;
        var downKeyDown = false;
        var leftKeyDown = false;
        var rightKeyDown = false;

        var player;
        var playerSpeed = 3;
        var playerRadius = 20;
        var shaftCollision, coinCollision;
        var incrementLives = false;
        var decrementLives = false;
        var collisionObject = {};
        var hasIncSpeed = false;

        var gameoverObject;
        var scoreboard;
        var storeBestScore = false;
        var alreadyStoredBestScore = false;

        $scope.$storage = $localStorage.$default({
            bestScores: []
        });
        $scope.$storage.bestScores = _.sortBy($scope.$storage.bestScores, function(n) {
            return -n
        });
        $scope.numBestScores = 5;
        $scope.level = 1;
        $scope.score = 0;
        $scope.lives = 10;
        $scope.gameOver = false;
        $scope.startCount = function() {
            $interval(function() {
                if (!$scope.gameOver) {
                    $scope.level++;
                }
            }, 5000);
            $interval(function() {
                if (!$scope.gameOver) {
                    $scope.score++;
                }
            }, 100);
        };

        $scope.restart = function() {
            $scope.gameOver = false;
            $scope.level = 1;
            $scope.score = 0;
            $scope.startCount();
            resetSpeed()
            createPlayer();
            scoreboard.visible = false;
            gameoverObject.visible = false;
            if (storeBestScore) storeBestScore = false;
            if (alreadyStoredBestScore) alreadyStoredBestScore = false;
        };

        $scope.start = function() {
            $scope.playing = true;
            resetSpeed()
            createPlayer();
            $scope.startCount();
        };

        var Colors = {
            red: 0xff3c46,
            white: 0xd8d0d1,
            green: 0xbdf566,
            orange: 0xF5986E,
            pink: 0xff5d93,
            purple: 0xa48bff,
            blue: 0x69ceec,
            yellow: 0xf4c637,
            emerald: 0x019875,
            tangerine: 0xf05442
        };

        var gameoverMaterial = new THREE.MeshPhongMaterial({
            color: Colors.red
        });
        var redMaterial = new THREE.MeshPhongMaterial({
            color: Colors.red,
            shading: THREE.FlatShading
        });
        var whiteMaterial = new THREE.MeshPhongMaterial({
            color: Colors.white,
            shading: THREE.FlatShading
        });
        var greenMaterial = new THREE.MeshPhongMaterial({
            color: Colors.green,
            shading: THREE.FlatShading
        });
        var purpleMaterial = new THREE.MeshPhongMaterial({
            color: Colors.purple,
            shading: THREE.FlatShading
        });
        var blueMaterial = new THREE.MeshPhongMaterial({
            color: Colors.blue,
            shading: THREE.FlatShading
        });
        var orangeMaterial = new THREE.MeshPhongMaterial({
            color: Colors.orange,
            shading: THREE.FlatShading
        });
        var yellowMaterial = new THREE.MeshPhongMaterial({
            color: Colors.yellow,
            shading: THREE.FlatShading
        });
        var pinkMaterial = new THREE.MeshPhongMaterial({
            color: Colors.pink,
            shading: THREE.FlatShading
        });
        var emeraldMaterial = new THREE.MeshPhongMaterial({
            color: Colors.emerald,
            shading: THREE.FlatShading
        });
        var tangerineMaterial = new THREE.MeshPhongMaterial({
            color: Colors.tangerine,
            shading: THREE.FlatShading
        });

        init();
        animate();

        function init() {
            // passin { antialias: true } to WebGLRenderer for better rendering
            renderer = new THREE.WebGLRenderer({
                alpha: true
            }); // init like this
            renderer.setClearColor(0xffffff, 0); // second param is opacity, 0 => transparent
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('world').appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 400;

            scene = new THREE.Scene();

            var platformGeometry = new THREE.BoxBufferGeometry(100, 20, 100, 20, 20, 20);
            var coinGeometry = new THREE.CylinderBufferGeometry(10, 10, 5, 32, 32, false);
            coinGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(90)));
            coinGeometry.applyMatrix(new THREE.Matrix4().makeRotationY(THREE.Math.degToRad(90)));

            createLights(scene);
            createCoin(coinGeometry);
            createShafts(platformGeometry);
            createDisappearingShafts(platformGeometry);
            createSpikes(redMaterial);
            createGameover3Dtext(scene);

            // event listenters
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);

        }

        function createGameover3Dtext(scene) {
            var loader = new THREE.FontLoader();
            loader.load('Minecrafter_Regular.typeface.js', function(font) {
                var gameoverGeo = new THREE.TextGeometry("GAME OVER", {
                    font: font,
                    size: 25
                });
                gameoverGeo.applyMatrix(new THREE.Matrix4().makeTranslation(-107.5, 80, 100));
                gameoverObject = new THREE.Mesh(gameoverGeo, gameoverMaterial);
                scene.add(gameoverObject);
                var scoreboardGeo = new THREE.BoxBufferGeometry(250, 250, 50);
                scoreboard = new THREE.Mesh(scoreboardGeo, whiteMaterial);
                scoreboard.position.set(0, 0, 100)
                scene.add(scoreboard);
                scoreboard.visible = false;
                gameoverObject.visible = false;
            });
        }

        function resetSpeed() {
            shaftSpeed = 3;
            playerSpeed = shaftSpeed;
        }

        function onKeyDown(e) {
            switch (e.keyCode) {
                case 37:
                    leftKeyDown = true;
                    break;
                case 39:
                    rightKeyDown = true;
                    break;
            }
        }

        function createPlayer() {
            var cubeGeometry = new THREE.CubeGeometry(20, 40, 20);
            player = new THREE.Mesh(cubeGeometry);
            scene.add(player);

            var platformGeometry = new THREE.BoxBufferGeometry(100, 20, 100, 20, 20, 20);
            var mesh = new THREE.Mesh(platformGeometry, blueMaterial);
            mesh.position.set(0, -100, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);
        }

        function onKeyUp(e) {
            switch (e.keyCode) {
                case 37:
                    leftKeyDown = false;
                    break;
                case 39:
                    rightKeyDown = false;
                    break;
            }
        }

        function createCoin(coinGeometry) {
            var mesh;
            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(200, 100, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(-250, 150, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(-100, -150, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(500, 50, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(350, 200, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);
        }

        function createDisappearingShafts(geometry) {
            mesh = new THREE.Mesh(geometry, pinkMaterial);
            mesh.position.set(100, -100, 0);
            mesh.itemType = 'byeShaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, pinkMaterial);
            mesh.position.set(250, 250, 0);
            mesh.itemType = 'byeShaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, pinkMaterial);
            mesh.position.set(-250, 350, 0);
            mesh.itemType = 'byeShaft';
            scene.add(mesh);
            items.push(mesh);
        }

        function createShafts(geometry) {
            var mesh;

            mesh = new THREE.Mesh(geometry, emeraldMaterial);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);


            mesh = new THREE.Mesh(geometry, orangeMaterial);
            mesh.position.set(100, -150, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, purpleMaterial);
            mesh.position.set(150, 50, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, tangerineMaterial);
            mesh.position.set(-100, 450, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, purpleMaterial);
            mesh.position.set(-100, 400, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, orangeMaterial);
            mesh.position.set(-500, -200, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, emeraldMaterial);
            mesh.position.set(500, -350, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, greenMaterial);
            mesh.position.set(250, -50, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);
        }

        function createSpikes() {
            var mesh;

            var combined = new THREE.Geometry();
            var deltaX = 25;
            var deltaZ = 25;
            var x = 75;
            var z;
            var base = new THREE.BoxGeometry(100, 20, 75, 20, 20, 20);
            base.applyMatrix(new THREE.Matrix4().makeTranslation(137, 150, 12));
            combined.merge(base, base.matrix);
            for (var i = 1; i < 5; i++) {
                x += deltaX;
                z = -40;
                for (var j = 1; j < 4; j++) {
                    z += deltaZ;
                    var spike = new THREE.CylinderGeometry(0, 15, 25, 15, 1, true);
                    spike.applyMatrix(new THREE.Matrix4().makeTranslation(x, 160, z));
                    combined.merge(spike, spike.matrix);
                }
            }
            mesh = new THREE.Mesh(combined, redMaterial);
            mesh.itemType = 'spikyShaft';
            items.push(mesh);
            scene.add(mesh);

            combined = new THREE.Geometry();
            deltaX = 25;
            deltaZ = 25;
            x = 175;
            base = new THREE.BoxGeometry(100, 20, 100, 20, 20, 20);
            base.applyMatrix(new THREE.Matrix4().makeTranslation(237, -160, 12));
            combined.merge(base, base.matrix);
            for (var i = 1; i < 5; i++) {
                x += deltaX;
                z = -40;
                for (var j = 1; j < 4; j++) {
                    z += deltaZ;
                    var spike = new THREE.CylinderGeometry(0, 15, 25, 15, 1, true);
                    spike.applyMatrix(new THREE.Matrix4().makeTranslation(x, -150, z));
                    combined.merge(spike, spike.matrix);
                }
            }
            mesh = new THREE.Mesh(combined, redMaterial);
            mesh.itemType = 'spikyShaft';
            items.push(mesh);
            scene.add(mesh);
        }

        function changeItemPositionX(item, items) {
            var curOccupiedX = items.map(shaft => shaft.position.x);
            var xPositionArr = _.range(-400, 400, 100);
            item.position.x = _.sample(xPositionArr);
            //
            var noOverlap = false;
            while (!noOverlap) {
                noOverlap = true;
                for (var i = 0; i < curOccupiedX.length; i++) {
                    item.position.x = _.sample(xPositionArr)
                    var diff = Math.abs(item.position.x - curOccupiedX[i]);
                    if (diff < 190) {
                        noOverlap &= false;
                        break;
                    }
                }
            }
        }

        function changeItemPositionY(item, items) {
            var curOccupiedY = items.map(shaft => shaft.position.y);
            var yPositionArr = _.range(-350, 350, 50);
            item.position.y = _.sample(yPositionArr);
            //
            var noOverlap = false;
            while (!noOverlap) {
                noOverlap = true;
                for (var i = 0; i < curOccupiedY.length; i++) {
                    item.position.y = _.sample(yPositionArr)
                    var diff = Math.abs(item.position.y - curOccupiedY[i]);
                    if (diff < 50) {
                        noOverlap &= false;
                        break;
                    }
                }
            }
        }

        function changePosition(item, items) {
            changeItemPositionX(item, items);
            changeItemPositionY(item, items);
            item.position.y = -350;
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function getRandomBool(float) {
            return Math.random() > float;
        }

        function rotateAroundObjAxisY(coin) {
            coin.rotation.y -= rotSpeed;
        }

        function updateScoreBoard(score, bestScores, numBestScores) {
            if (bestScores.indexOf(score) === -1) {
                bestScores.splice(_.sortedIndexBy(bestScores, score, function(n) {
                    return -n
                }), 0, score);
                if (bestScores.length >= numBestScores) {
                    bestScores.splice(-1, 1);
                }
            }
        }

        function animate() {

            if (storeBestScore) {
                updateScoreBoard($scope.score, $scope.$storage.bestScores, $scope.numBestScores)
                alreadyStoredBestScore = true;
            }

            if ($scope.gameOver) {
                scoreboard.visible = true;
                gameoverObject.visible = true;
                if (!alreadyStoredBestScore) {
                    storeBestScore = true;
                } else {
                    storeBestScore = false;
                }
            }

            shaftCollision = false;
            coinCollision = false;
            if (incrementLives) {
                incrementLives = false;
                if ($scope.lives < 10) $scope.lives += 1;
                else $scope.lives = 10;
                setTimeout(function() {
                    collisionObject = {};
                }, 5000)
            }
            if (decrementLives) {
                decrementLives = false;
                if ($scope.lives > 0) $scope.lives -= 1;
                else $scope.gameOver = true;
                resetSpeed();
                setTimeout(function() {
                    collisionObject = {};
                }, 5000)
            }

            shaftSpeed += 0.0005;
            playerSpeed = shaftSpeed;

            requestAnimationFrame(animate);

            // prevent shafts from falling out of the screen
            for (var i = 0; i < items.length; i++) {

                if (items[i].itemType === 'coin') rotateAroundObjAxisY(items[i]);
                if (items[i].position.y > 350 && items[i].itemType !== 'spikyShaft') {
                    changeItemPositionX(items[i], items);
                    items[i].position.y = -350;
                } else if (items[i].position.y > 500 && items[i].itemType === 'spikyShaft') {
                    items[i].position.y = -500;
                } else {
                    // check for getting coins
                    if (items[i].itemType === 'coin') {
                        if (player) {
                            if (items[i].position.distanceTo(player.position) < 15) {
                                changePosition(items[i], items);
                                $scope.score += 100;
                            }
                        }
                    }
                    items[i].position.y += shaftSpeed;
                }

            }

            if ($scope.playing) {
                if (player.position.y < -310) {
                    $scope.gameOver = true;
                    resetSpeed()
                    scene.remove(player)
                }

                // check for landing on shaft
                var originPoint = player.position.clone();
                for (var vertexIndex = 0; vertexIndex < player.geometry.vertices.length; vertexIndex++) {
                    var localVertex = player.geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(player.matrix);
                    var directionVector = globalVertex.sub(player.position);
                    var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
                    var collisionResults = ray.intersectObjects(items);
                    if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
                        shaftCollision = true;
                        if (collisionResults[0].object.itemType === 'shaft') {
                            if (collisionObject !== collisionResults[0].object) {
                                incrementLives = true;
                                collisionObject = collisionResults[0].object
                            }
                        }
                        if (collisionResults[0].object.itemType === 'spikyShaft') {
                            if (collisionObject !== collisionResults[0].object) {
                                decrementLives = true;
                                collisionObject = collisionResults[0].object
                            }
                        }
                        if (collisionResults[0].object.itemType === 'byeShaft') {
                            setTimeout(function() {
                                changePosition(collisionResults[0].object, items);
                            }, 300);
                        }
                    }
                }

                // player movement
                if (upKeyDown == true) player.position.y += playerSpeed;
                if (downKeyDown == true) player.position.y -= playerSpeed;
                if (leftKeyDown == true) player.position.x -= playerSpeed;
                if (rightKeyDown == true) player.position.x += playerSpeed;
                if (shaftCollision == true) {
                    player.position.y += playerSpeed;
                } else {
                    player.position.y -= playerSpeed * 2;
                }

            }

            renderer.render(scene, camera);

        }

    });
    </script>
</body>

</html>
