<!DOCTYPE html>
<html lang="en">

<head>
    <title>ns-shafts</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:800' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="main.css">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ngStorage/0.3.6/ngStorage.min.js"></script>
</head>

<body ng-app="threeDShaft" ng-controller="threeDShaft">
    <div id="world">
        <div id="dashboard" ng-hide="gameOver || !playing">
            <p id="level">B{{ level }} 分數: {{ score }}</p>
        </div>
        <button name="restart" ng-show="gameOver" ng-click="restart()">TRY AGAIN</button>
        <ul class="scoreboard" ng-show="gameOver">
            <li>YOUR HIGHEST SCORES</li>
            <li ng-repeat="score in $storage.bestScores track by $index">
                <span>{{score}}</span>
            </li>
        </ul>
        <div ng-hide="playing" class="scoreboard">
            <p id="logo">
                小朋友下樓梯 3D版
                <br>
                <button name="start" ng-click="start()">PLAY</button>
            </p>
        </div>
    </div>
    <script src="src/three.js"></script>
    <script type="text/javascript" src="model.js"></script>
    <script type="text/javascript" src="src/ObjectLoader.js"></script>
    <script type="text/javascript" src="light.js"></script>
    <script>
    var app = angular.module('threeDShaft', ['ngStorage']);
    app.controller('threeDShaft', function($scope, $interval, $localStorage) {

        var camera, scene, renderer;
        var items = [];
        var lives = [];

        var upKeyDown = false;
        var downKeyDown = false;
        var leftKeyDown = false;
        var rightKeyDown = false;

        var player;
        var playerClone;
        var playerSpeed = 3;
        var playerRadius = 20;
        var shaftSpeed = 3;
        var rotSpeed = 0.2;
        var shaftHeight = 20;
        var shaftYCollision, coinCollision;
        var collisionObject = {};
        var incrementLives = false;
        var decrementLives = false;

        var gameoverObject;
        var scoreboard;
        var storeBestScore = false;
        var alreadyStoredBestScore = false;

        var topNormalVec = {
            x: 0,
            y: 1,
            z: 0
        };
        var bottomNormalVec = {
            x: 0,
            y: -1,
            z: 0
        };
        var leftNormalVec = {
            x: -1,
            y: 0,
            z: 0
        };
        var rightNormalVec = {
            x: 1,
            y: 0,
            z: 0
        };

        var jumpAudio = document.createElement('audio');
        var rightCrossAudio = document.createElement('audio');
        var screamAudio = document.createElement('audio');
        var coinAudio = document.createElement('audio');
        jumpAudio.src = 'jump.mp3';
        rightCrossAudio.src = 'rightCross.mp3';
        screamAudio.src = 'scream.mp3';
        coinAudio.src = 'coin.mp3'
        jumpAudio.load();
        rightCrossAudio.load();
        screamAudio.load();
        coinAudio.load();

        $scope.$storage = $localStorage.$default({
            bestScores: []
        });
        $scope.$storage.bestScores = _.sortBy($scope.$storage.bestScores, function(n) {
            return -n
        });
        $scope.numBestScores = 5;
        $scope.level = 1;
        $scope.score = 0;
        $scope.lives = 10;
        $scope.gameOver = false;
        $scope.startCount = function() {
            $interval(function() {
                if (!$scope.gameOver) {
                    $scope.level++;
                }
            }, 5000);
            $interval(function() {
                if (!$scope.gameOver) {
                    $scope.score++;
                }
            }, 100);
        };

        $scope.restart = function() {
            $scope.gameOver = false;
            updateLives(10);
            $scope.lives = 10;
            $scope.level = 1;
            $scope.score = 0;
            $scope.startCount();
            resetSpeed()
            createPlayer('TC')
            scoreboard.visible = false;
            gameoverObject.visible = false;
            if (storeBestScore) storeBestScore = false;
            if (alreadyStoredBestScore) alreadyStoredBestScore = false;
        };

        $scope.start = function() {
            $scope.playing = true;
            resetSpeed()
            createPlayer('TC')
            $scope.startCount();
        };

        var Colors = {
            red: 0xff3c46,
            white: 0xd8d0d1,
            green: 0xbdf566,
            orange: 0xF5986E,
            pink: 0xff5d93,
            purple: 0xa48bff,
            blue: 0x69ceec,
            yellow: 0xf4c637,
            yellowDark: 0xffc72a,
            emerald: 0x019875,
            tangerine: 0xf05442
        };

        var gameoverMaterial = new THREE.MeshPhongMaterial({
            color: Colors.red
        });
        var redMaterial = new THREE.MeshPhongMaterial({
            color: Colors.red,
            shading: THREE.FlatShading
        });
        var whiteMaterial = new THREE.MeshPhongMaterial({
            color: Colors.white,
            shading: THREE.FlatShading
        });
        var greenMaterial = new THREE.MeshPhongMaterial({
            color: Colors.green,
            shading: THREE.FlatShading
        });
        var purpleMaterial = new THREE.MeshPhongMaterial({
            color: Colors.purple,
            shading: THREE.FlatShading
        });
        var blueMaterial = new THREE.MeshPhongMaterial({
            color: Colors.blue,
            shading: THREE.FlatShading
        });
        var orangeMaterial = new THREE.MeshPhongMaterial({
            color: Colors.orange,
            shading: THREE.FlatShading
        });
        var yellowMaterial = new THREE.MeshPhongMaterial({
            color: Colors.yellow,
            shading: THREE.FlatShading
        });
        var yellowDarkMaterial = new THREE.MeshPhongMaterial({
            color: Colors.yellowDark,
            shading: THREE.FlatShading
        });
        var pinkMaterial = new THREE.MeshPhongMaterial({
            color: Colors.pink,
            shading: THREE.FlatShading
        });
        var emeraldMaterial = new THREE.MeshPhongMaterial({
            color: Colors.emerald,
            shading: THREE.FlatShading
        });
        var tangerineMaterial = new THREE.MeshPhongMaterial({
            color: Colors.tangerine,
            shading: THREE.FlatShading
        });

        init();
        animate();

        function init() {
            // passin { antialias: true } to WebGLRenderer for better rendering
            renderer = new THREE.WebGLRenderer({
                alpha: true
            }); // init like this
            renderer.setClearColor(0xffffff, 0); // second param is opacity, 0 => transparent
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('world').appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 400;

            scene = new THREE.Scene();

            var platformGeometry = new THREE.BoxBufferGeometry(100, 20, 100, 20, 20, 20);
            var coinGeometry = new THREE.CylinderBufferGeometry(10, 10, 5, 32, 32, false);
            coinGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(90)));
            coinGeometry.applyMatrix(new THREE.Matrix4().makeRotationY(THREE.Math.degToRad(90)));

            createLights(scene);
            createCoin(coinGeometry);
            createShafts(platformGeometry);
            createDisappearingShafts(platformGeometry);
            createSpikes(redMaterial);
            createGameover3Dtext(scene);
            createLives(scene);

            // event listenters
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);

        }

        function createGameover3Dtext(scene) {
            var loader = new THREE.FontLoader();
            loader.load('Minecrafter_Regular.typeface.js', function(font) {
                var gameoverGeo = new THREE.TextGeometry("GAME OVER", {
                    font: font,
                    size: 25
                });
                gameoverGeo.applyMatrix(new THREE.Matrix4().makeTranslation(-107.5, 80, 100));
                gameoverObject = new THREE.Mesh(gameoverGeo, gameoverMaterial);
                scene.add(gameoverObject);
                var scoreboardGeo = new THREE.BoxBufferGeometry(250, 250, 50);
                scoreboard = new THREE.Mesh(scoreboardGeo, whiteMaterial);
                scoreboard.position.set(0, 0, 100)
                scene.add(scoreboard);
                scoreboard.visible = false;
                gameoverObject.visible = false;
            });
        }

        function resetSpeed() {
            shaftSpeed = 3;
            playerSpeed = shaftSpeed;
        }

        function onKeyDown(e) {
            switch (e.keyCode) {
                case 37:
                    leftKeyDown = true;
                    break;
                case 39:
                    rightKeyDown = true;
                    break;
            }
        }

        function createPlayer(name) {
            // default player is a cube
            if (!name) {
                if (player) scene.remove(player);
                var cubeGeometry = new THREE.CubeGeometry(20, 40, 20);
                player = new THREE.Mesh(cubeGeometry);
                scene.add(player);
            }
            if (name === 'TC') {
                createTammyChu();
            }
            var platformGeometry = new THREE.BoxBufferGeometry(100, 20, 100, 20, 20, 20);
            var mesh = new THREE.Mesh(platformGeometry, blueMaterial);
            mesh.position.set(0, -100, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);
            playerClone = (player.children.length > 1) ? player.children[0] : player;
        }

        function createTammyChu() {
            var mesh;
            player = new THREE.Object3D();//create an empty container
            var face = new THREE.CubeGeometry(40, 40, 40);
            var faceMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFD479,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(face, faceMaterial);
            player.add( mesh );

            var hatBase = new THREE.CubeGeometry(60, 8, 40);
            var hatMaterial = new THREE.MeshPhongMaterial({
                color: 0x014175,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(hatBase, hatMaterial);
            mesh.position.set(10, 24, 0);
            player.add( mesh );

            var hat = new THREE.CubeGeometry(40, 20, 40);
            var hatMaterial = new THREE.MeshPhongMaterial({
                color: 0x014175,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(hat, hatMaterial);
            mesh.position.set(0, 32, 0);
            player.add( mesh );

            var eye = new THREE.CubeGeometry(10, 2, 2);
            var eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(eye, eyeMaterial);
            mesh.position.set(-10, 8, 20);
            player.add( mesh );

            var eye = new THREE.CubeGeometry(10, 2, 2);
            var eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(eye, eyeMaterial);
            mesh.position.set(10, 8, 20);
            player.add( mesh );
            scene.add(player);
        }

        function onKeyUp(e) {
            switch (e.keyCode) {
                case 37:
                    leftKeyDown = false;
                    break;
                case 39:
                    rightKeyDown = false;
                    break;
            }
        }

        function createCoin(coinGeometry) {
            var mesh;
            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(200, 100, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(-250, 150, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(-100, -150, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(500, 50, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(350, 200, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);
        }

        function createDisappearingShafts(geometry) {
            mesh = new THREE.Mesh(geometry, pinkMaterial);
            mesh.position.set(100, -100, 0);
            mesh.itemType = 'byeShaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, pinkMaterial);
            mesh.position.set(250, 250, 0);
            mesh.itemType = 'byeShaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, pinkMaterial);
            mesh.position.set(-250, 350, 0);
            mesh.itemType = 'byeShaft';
            scene.add(mesh);
            items.push(mesh);
        }

        function createShafts(geometry) {
            var mesh;

            mesh = new THREE.Mesh(geometry, emeraldMaterial);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);


            mesh = new THREE.Mesh(geometry, orangeMaterial);
            mesh.position.set(100, -150, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, purpleMaterial);
            mesh.position.set(150, 50, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, tangerineMaterial);
            mesh.position.set(-100, 450, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, purpleMaterial);
            mesh.position.set(-100, 400, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, orangeMaterial);
            mesh.position.set(-500, -200, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, emeraldMaterial);
            mesh.position.set(500, -350, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, greenMaterial);
            mesh.position.set(250, -50, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);
        }

        function createSpikes() {
            var mesh;

            var combined = new THREE.Geometry();
            var deltaX = 25;
            var deltaZ = 25;
            var x = 75;
            var z;
            var base = new THREE.BoxGeometry(100, 20, 75, 20, 20, 20);
            base.applyMatrix(new THREE.Matrix4().makeTranslation(137, 150, 12));
            combined.merge(base, base.matrix);
            for (var i = 1; i < 5; i++) {
                x += deltaX;
                z = -40;
                for (var j = 1; j < 4; j++) {
                    z += deltaZ;
                    var spike = new THREE.CylinderGeometry(0, 15, 25, 15, 1, true);
                    spike.applyMatrix(new THREE.Matrix4().makeTranslation(x, 160, z));
                    combined.merge(spike, spike.matrix);
                }
            }
            mesh = new THREE.Mesh(combined, redMaterial);
            mesh.itemType = 'spikyShaft';
            items.push(mesh);
            scene.add(mesh);

            combined = new THREE.Geometry();
            deltaX = 25;
            deltaZ = 25;
            x = 175;
            base = new THREE.BoxGeometry(100, 20, 100, 20, 20, 20);
            base.applyMatrix(new THREE.Matrix4().makeTranslation(237, -160, 12));
            combined.merge(base, base.matrix);
            for (var i = 1; i < 5; i++) {
                x += deltaX;
                z = -40;
                for (var j = 1; j < 4; j++) {
                    z += deltaZ;
                    var spike = new THREE.CylinderGeometry(0, 15, 25, 15, 1, true);
                    spike.applyMatrix(new THREE.Matrix4().makeTranslation(x, -150, z));
                    combined.merge(spike, spike.matrix);
                }
            }
            mesh = new THREE.Mesh(combined, redMaterial);
            mesh.itemType = 'spikyShaft';
            items.push(mesh);
            scene.add(mesh);
        }

        function changeItemPositionX(item, items) {
            var curOccupiedX = items.map(shaft => shaft.position.x);
            var xPositionArr = _.range(-400, 400, 100);
            item.position.x = _.sample(xPositionArr);
            //
            var noOverlap = false;
            while (!noOverlap) {
                noOverlap = true;
                for (var i = 0; i < curOccupiedX.length; i++) {
                    item.position.x = _.sample(xPositionArr)
                    var diff = Math.abs(item.position.x - curOccupiedX[i]);
                    if (diff < 190) {
                        noOverlap &= false;
                        break;
                    }
                }
            }
        }

        function changeItemPositionY(item, items) {
            var curOccupiedY = items.map(shaft => shaft.position.y);
            var yPositionArr = _.range(-350, 350, 50);
            item.position.y = _.sample(yPositionArr);
            //
            var noOverlap = false;
            while (!noOverlap) {
                noOverlap = true;
                for (var i = 0; i < curOccupiedY.length; i++) {
                    item.position.y = _.sample(yPositionArr)
                    var diff = Math.abs(item.position.y - curOccupiedY[i]);
                    if (diff < 50) {
                        noOverlap &= false;
                        break;
                    }
                }
            }
        }

        function changePosition(item, items) {
            changeItemPositionX(item, items);
            changeItemPositionY(item, items);
            item.position.y = -350;
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function getRandomBool(float) {
            return Math.random() > float;
        }

        function rotateAroundObjAxisY(coin) {
            coin.rotation.y -= rotSpeed;
        }

        function updateScoreBoard(score, bestScores, numBestScores) {
            if (bestScores.indexOf(score) === -1) {
                bestScores.splice(_.sortedIndexBy(bestScores, score, function(n) {
                    return -n
                }), 0, score);
                if (bestScores.length >= numBestScores) {
                    bestScores.splice(-1, 1);
                }
            }
        }

        function createLives(scene) {
            var x = -45;
            var barGeo, bar;
            for (var i = 0; i < 10; i++) {
                barGeo = new THREE.BoxBufferGeometry(7, 20, 20);
                barGeo = new THREE.BoxBufferGeometry(7, 20, 20);
                bar = new THREE.Mesh(barGeo, yellowDarkMaterial);
                bar.position.set(x, 180, 100);
                scene.add(bar);
                bar.visible = false;
                lives.push(bar);
                x += 10;
            }
        }

        function updateLives(numLives) {
            if (numLives <= 0) $scope.gameOver = true;
            if ($scope.gameOver || !$scope.playing) {
                for (var i = 0; i < 10; i++) {
                    lives[i].visible = false;
                }
            } else {
                for (var i = 0; i < numLives; i++) {
                    lives[i].visible = true;
                }
                for (i; i < 10; i++) {
                    lives[i].visible = false;
                }
            }
        }

        function compareWithUnitNormVec(vec, unitNormVec) {
            var compareX = vec.x === unitNormVec.x;
            var compareY = vec.y === unitNormVec.y;
            var compareZ = vec.z === unitNormVec.z;
            return [compareX, compareY, compareZ];
        }

        function animate() {

            shaftXCollisionFromLeft = false;
            shaftXCollisionFromRight = false;
            shaftYCollision = false;
            coinCollision = false;
            shaftSpeed += 0.0005;
            playerSpeed = shaftSpeed;

            if (storeBestScore) {
                updateScoreBoard($scope.score, $scope.$storage.bestScores, $scope.numBestScores)
                alreadyStoredBestScore = true;
            }

            if ($scope.gameOver) {
                scene.remove(player);
                scoreboard.visible = true;
                gameoverObject.visible = true;
                if (!alreadyStoredBestScore) {
                    screamAudio.play();
                    storeBestScore = true;
                } else {
                    storeBestScore = false;
                }
                updateLives(0);
            } else {
                updateLives($scope.lives);
            }

            if (incrementLives) {
                incrementLives = false;
                if ($scope.lives < 10) $scope.lives += 1;
                else $scope.lives = 10;
                setTimeout(function() {
                    collisionObject = {};
                }, 5000)
            }

            if (decrementLives) {
                decrementLives = false;
                if ($scope.lives > 0) $scope.lives -= 1;
                else $scope.gameOver = true;
                resetSpeed();
                setTimeout(function() {
                    collisionObject = {};
                }, 5000)
            }

            requestAnimationFrame(animate);

            // prevent shafts from falling out of the screen
            for (var i = 0; i < items.length; i++) {

                if (items[i].itemType === 'coin') rotateAroundObjAxisY(items[i]);
                if (items[i].position.y > 350 && items[i].itemType !== 'spikyShaft') {
                    changeItemPositionX(items[i], items);
                    items[i].position.y = -350;
                } else if (items[i].position.y > 500 && items[i].itemType === 'spikyShaft') {
                    items[i].position.y = -500;
                } else {
                    // check for getting coins
                    if (items[i].itemType === 'coin') {
                        if (player) {
                            if (items[i].position.distanceTo(playerClone.position) < 15) {
                                changePosition(items[i], items);
                                coinAudio.play();
                                $scope.score += 100;
                            }
                        }
                    }
                    items[i].position.y += shaftSpeed;
                }

            }

            if ($scope.playing) {
                if (playerClone.position.y < -310) {
                    $scope.gameOver = true;
                    resetSpeed()
                    scene.remove(player)
                }

                // check for landing on shaft
                var originPoint = playerClone.position.clone();
                for (var vertexIndex = 0; vertexIndex < playerClone.geometry.vertices.length; vertexIndex++) {
                    var localVertex = playerClone.geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(playerClone.matrix);
                    var directionVector = globalVertex.sub(playerClone.position);
                    var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
                    var collisionResults = ray.intersectObjects(items);
                    if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
                        var [compareTopX, compareTopY, compareTopZ] = compareWithUnitNormVec(collisionResults[0].face.normal, topNormalVec)
                        var [compareLeftX, compareLeftY, compareLeftZ] = compareWithUnitNormVec(collisionResults[0].face.normal, leftNormalVec);
                        var [compareRightX, compareRightY, compareRightZ] = compareWithUnitNormVec(collisionResults[0].face.normal, rightNormalVec);
                        if (compareLeftX && compareLeftY && compareLeftZ) shaftXCollisionFromLeft = true;
                        if (compareRightX && compareRightY && compareRightZ) shaftXCollisionFromRight = true;
                        if (compareTopX && compareTopY && compareTopZ) {
                            shaftYCollision = true;
                            if (collisionResults[0].object.itemType === 'shaft') {
                                if (collisionObject !== collisionResults[0].object) {
                                    incrementLives = true;
                                    jumpAudio.play();
                                }
                            }
                            if (collisionResults[0].object.itemType === 'spikyShaft') {
                                if (collisionObject !== collisionResults[0].object) {
                                    decrementLives = true;
                                    rightCrossAudio.play();
                                }
                            }
                            if (collisionResults[0].object.itemType === 'byeShaft') {
                                setTimeout(function () {
                                    if (collisionResults[0]) changePosition(collisionResults[0].object, items);
                                }, 300);
                                if (collisionObject !== collisionResults[0].object) {
                                    jumpAudio.play();
                                }
                            }
                            collisionObject = collisionResults[0].object;
                        }
                    }
                }

                // player movement
                if (upKeyDown == true) player.position.y += playerSpeed;
                if (downKeyDown == true) player.position.y -= playerSpeed;
                if (leftKeyDown == true && !shaftXCollisionFromRight) {
                    player.children.forEach(function (child) {
                        child.position.x -= playerSpeed;
                    })
                    // player.position.x -= playerSpeed
                };
                if (rightKeyDown == true && !shaftXCollisionFromLeft) {
                    player.children.forEach(function (child) {
                        child.position.x += playerSpeed;
                    })
                    // player.position.x += playerSpeed;
                }
                if (shaftYCollision == true) {
                    player.children.forEach(function (child) {
                        child.position.y += playerSpeed;
                    })
                    // player.position.y += playerSpeed;
                } else {
                    player.children.forEach(function (child) {
                        child.position.y -= playerSpeed * 2;
                    })
                    // player.position.y -= playerSpeed * 2;
                }

            }

            renderer.render(scene, camera);

        }

    });
    </script>
</body>

</html>
