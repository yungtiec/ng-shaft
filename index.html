<!DOCTYPE html>
<html lang="en">

<head>
    <title>ns-shafts</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="google-signin-clientid" content="148406620227-cslkm2tnvljg98gphs7a8ubbpi3k70mo.apps.googleusercontent.com" />
    <meta name="google-signin-cookiepolicy" content="single_host_origin" />
    <meta name="google-signin-approvalprompt" content="auto" />
    <!-- <meta name="google-signin-callback" content="signinCallback" /> -->
    <meta name="google-signin-scope" content="https://www.googleapis.com/auth/games" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:800' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="main.css">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ngStorage/0.3.6/ngStorage.min.js"></script>
</head>

<body ng-app="threeDShaft" ng-controller="threeDShaft">
    <div id="world">
        <div id="dashboard" ng-hide="gameOver || !playing">
            <p id="level">B{{ level }} 分數: {{ score }}</p>
        </div>
        <div id="current-score" ng-show="gameOver && !scoreboard && !leaderboard">
            <h3>{{score}}</h3>
            <button name="leaderboard" ng-click="goToLeaderboard()">SEE LEADERBOARD</button>
            <button name="scoreboard" ng-click="goToScoreboard()">SEE YOUR BEST SCORES</button>
        </div>
        <div id="scoreboard" ng-show="gameOver && scoreboard">
            <button name="restart" ng-click="restart()">TRY AGAIN</button>
            <ul class="scoreboard">
                <li>YOUR HIGHEST SCORES</li>
                <li ng-repeat="score in $storage.bestScores track by $index">
                    <span>{{score}}</span>
                </li>
            </ul>
        </div>
        <div id="leaderboard" ng-show="gameOver && leaderboard">
            <div id="my-signin"></div>
            <button name="restart" ng-click="restart()">PLAY AGAIN</button>
        </div>
        <div id="character-board" ng-show="!playerChosen">
            <p>PICK YOUR CHARACTER</p>
            <div class="choices">
                <div ng-click="setPlayerToCube()">A CUBE</div>
                <div ng-click="setPlayerToTC()">Tammy Chu</div>
                <div ng-click="setPlayerToHL()">Harrison Lo</div>
            </div>
        </div>
        <div ng-hide="playing || !playerChosen" class="scoreboard">
            <p id="logo">
                小朋友下樓梯 3D版
                <br>
                <button name="start" ng-click="start()">PLAY</button>
            </p>
        </div>
    </div>
    <script src="src/three.js"></script>
    <script type="text/javascript" src="light.js"></script>
    <script type="text/javascript" src="materials.js"></script>
    <script>
    (function() {
        var po = document.createElement('script');
        po.type = 'text/javascript';
        po.async = true;
        po.src = 'https://apis.google.com/js/client:plusone.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(po, s);
    })();
    </script>
    <script>
    function onSuccess(googleUser) {
        console.log('Logged in as: ' + googleUser.getBasicProfile().getName());
    }

    function onFailure(error) {
        console.log(error);
    }

    function renderButton() {
        gapi.signin2.render('my-signin', {
            'scope': 'profile email',
            'width': 380,
            'height': 50,
            'longtitle': true,
            'theme': 'dark',
            'onSuccess': onSuccess,
            'onFailure': onFailure
        });
    }
    </script>
    <script src="https://apis.google.com/js/platform.js?onload=renderButton" async defer></script>
    <script>
    var app = angular.module('threeDShaft', ['ngStorage']);
    app.controller('threeDShaft', function($scope, $interval, $localStorage) {

        var camera, scene, renderer;
        var items = [];
        var lives = [];

        var upKeyDown = false;
        var downKeyDown = false;
        var leftKeyDown = false;
        var rightKeyDown = false;

        var player;
        var playerClone;
        var playerSpeed = 3;
        var playerRadius = 20;

        var shaftSpeed = 3;
        var rotSpeed = 0.2;
        var shaftHeight = 20;
        var shaftYCollision, coinCollision;
        var collisionObject = {};

        var incrementLives = false;
        var decrementLives = false;

        var gameoverObject;
        var scoreboard;
        var storeBestScore = false;
        var alreadyStoredBestScore = false;

        // for display purpose
        var cubePlayer, tcPlayer, hlPlayer, board;

        var topNormalVec = {
            x: 0,
            y: 1,
            z: 0
        };
        var bottomNormalVec = {
            x: 0,
            y: -1,
            z: 0
        };
        var leftNormalVec = {
            x: -1,
            y: 0,
            z: 0
        };
        var rightNormalVec = {
            x: 1,
            y: 0,
            z: 0
        };

        var jumpAudio = document.createElement('audio');
        var rightCrossAudio = document.createElement('audio');
        var screamAudio = document.createElement('audio');
        var coinAudio = document.createElement('audio');
        jumpAudio.src = 'jump.mp3';
        rightCrossAudio.src = 'rightCross.mp3';
        screamAudio.src = 'scream.mp3';
        coinAudio.src = 'coin.mp3'
        jumpAudio.load();
        rightCrossAudio.load();
        screamAudio.load();
        coinAudio.load();

        $scope.$storage = $localStorage.$default({
            bestScores: []
        });
        $scope.$storage.bestScores = _.sortBy($scope.$storage.bestScores, function(n) {
            return -n
        });
        $scope.playerChosen = false;
        $scope.player = '';
        $scope.numBestScores = 5;
        $scope.level = 1;
        $scope.score = 0;
        $scope.lives = 10;
        $scope.gameOver = false;
        $scope.scoreboard = false;
        $scope.leaderboard = false;
        $scope.setPlayerToCube = function() {
            $scope.player = 'cube';
            $scope.playerChosen = true;
            board.visible = false;
            cubePlayer.visible = false;
            tcPlayer.visible = false;
            hlPlayer.visible = false;
        }
        $scope.setPlayerToTC = function() {
            $scope.player = 'TC';
            $scope.playerChosen = true;
            board.visible = false;
            cubePlayer.visible = false;
            tcPlayer.visible = false;
            hlPlayer.visible = false;
        }
        $scope.setPlayerToHL = function() {
            $scope.player = 'HL';
            $scope.playerChosen = true;
            board.visible = false;
            cubePlayer.visible = false;
            tcPlayer.visible = false;
            hlPlayer.visible = false;
        }
        $scope.startCount = function() {
            $interval(function() {
                if (!$scope.gameOver) {
                    $scope.level++;
                }
            }, 5000);
            $interval(function() {
                if (!$scope.gameOver) {
                    $scope.score++;
                }
            }, 100);
        };
        $scope.restart = function() {
            $scope.start()
            $scope.gameOver = false;
            updateLives(10);
            $scope.lives = 10;
            $scope.level = 1;
            $scope.score = 0;
            scoreboard.visible = false;
            gameoverObject.visible = false;
            $scope.scoreboard = false;
            $scope.leaderboard = false;
            if (storeBestScore) storeBestScore = false;
            if (alreadyStoredBestScore) alreadyStoredBestScore = false;
        };
        $scope.start = function() {
            $scope.playing = true;
            resetSpeed()
            createPlayer($scope.player)
            $scope.startCount();
        };
        $scope.goToScoreboard = function() {
            $scope.scoreboard = true;
        }
        $scope.goToLeaderboard = function() {
            $scope.leaderboard = true;
        }

        init();
        animate();

        function init() {
            // passin { antialias: true } to WebGLRenderer for better rendering
            renderer = new THREE.WebGLRenderer({
                alpha: true
            }); // init like this
            renderer.setClearColor(0xffffff, 0); // second param is opacity, 0 => transparent
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('world').appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 400;

            scene = new THREE.Scene();

            var platformGeometry = new THREE.BoxBufferGeometry(100, 20, 100, 20, 20, 20);
            var coinGeometry = new THREE.CylinderBufferGeometry(10, 10, 5, 32, 32, false);
            coinGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(90)));
            coinGeometry.applyMatrix(new THREE.Matrix4().makeRotationY(THREE.Math.degToRad(90)));

            createDisplayPlayer()
            createLights(scene);
            createCoin(coinGeometry);
            createShafts(platformGeometry);
            // createDisappearingShafts(platformGeometry);
            createSpikes(redMaterial);
            createGameover3Dtext(scene);
            createLives(scene);

            // event listenters
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);

        }

        function resetSpeed() {
            shaftSpeed = 3;
            playerSpeed = shaftSpeed;
        }

        function onKeyDown(e) {
            switch (e.keyCode) {
                case 37:
                    leftKeyDown = true;
                    break;
                case 39:
                    rightKeyDown = true;
                    break;
            }
        }

        function onKeyUp(e) {
            switch (e.keyCode) {
                case 37:
                    leftKeyDown = false;
                    break;
                case 39:
                    rightKeyDown = false;
                    break;
            }
        }

        function createGameover3Dtext(scene) {
            var loader = new THREE.FontLoader();
            loader.load('Minecrafter_Regular.typeface.js', function(font) {
                var gameoverGeo = new THREE.TextGeometry("GAME OVER", {
                    font: font,
                    size: 25
                });
                gameoverGeo.applyMatrix(new THREE.Matrix4().makeTranslation(-107.5, 80, 100));
                gameoverObject = new THREE.Mesh(gameoverGeo, gameoverMaterial);
                scene.add(gameoverObject);
                var scoreboardGeo = new THREE.BoxBufferGeometry(250, 250, 50);
                scoreboard = new THREE.Mesh(scoreboardGeo, whiteMaterial);
                scoreboard.position.set(0, 0, 100)
                scene.add(scoreboard);
                scoreboard.visible = false;
                gameoverObject.visible = false;
            });
        }

        function createPlayer(name) {
            // default player is a cube
            if (player) scene.remove(player);
            if (!name || name === 'cube') {
                createCube();
            }
            if (name === 'TC') {
                createTammyChu();
            }
            if (name === 'HL') {
                createHarrison();
            }
            // create a platform for player to stand on
            var platformGeometry = new THREE.BoxBufferGeometry(100, 20, 100, 20, 20, 20);
            var mesh = new THREE.Mesh(platformGeometry, blueMaterial);
            mesh.position.set(0, -100, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            playerClone = (player.children.length) ? player.children[0] : player;
        }

        function createDisplayPlayer() {
            // ideally should reuse player instance instead of creating new one
            // cube
            var cubeGeometry = new THREE.CubeGeometry(40, 40, 40);
            cubePlayer = new THREE.Mesh(cubeGeometry);
            cubePlayer.position.set(-75, 0, 100);
            scene.add(cubePlayer);

            // tammy chu
            var mesh;
            tcPlayer = new THREE.Object3D();
            var face = new THREE.CubeGeometry(40, 40, 40);
            var faceMaterial = new THREE.MeshPhongMaterial({
                color: 0xC68642,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(face, faceMaterial);
            tcPlayer.add(mesh);

            var hatBase = new THREE.CubeGeometry(60, 8, 40);
            var hatMaterial = new THREE.MeshPhongMaterial({
                color: 0x014175,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(hatBase, hatMaterial);
            mesh.position.set(10, 24, 0);
            tcPlayer.add(mesh);

            var hat = new THREE.CubeGeometry(40, 20, 40);
            var hatMaterial = new THREE.MeshPhongMaterial({
                color: 0x014175,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(hat, hatMaterial);
            mesh.position.set(0, 32, 0);
            tcPlayer.add(mesh);

            var eye = new THREE.CubeGeometry(10, 2, 2);
            var eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(eye, eyeMaterial);
            mesh.position.set(-10, 8, 20);
            tcPlayer.add(mesh);

            eye = new THREE.CubeGeometry(10, 2, 2);
            eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(eye, eyeMaterial);
            mesh.position.set(10, 8, 20);
            tcPlayer.add(mesh);
            tcPlayer.position.set(0, 0, 100);
            scene.add(tcPlayer);

            // harrison lo
            hlPlayer = new THREE.Object3D();
            var face = new THREE.CubeGeometry(40, 40, 40);
            var faceMaterial = new THREE.MeshPhongMaterial({
                color: 0xC68642,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(face, faceMaterial);
            mesh.position.set(0, 0, 0);
            hlPlayer.add(mesh);

            var hairBase = new THREE.CubeGeometry(40, 15, 40);
            var hairMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(hairBase, hairMaterial);
            mesh.position.set(0, 25, 0);
            hlPlayer.add(mesh);

            var glasses = new THREE.CubeGeometry(10, 2, 2);
            var glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(-10, 5, 20);
            hlPlayer.add(mesh);

            glasses = new THREE.CubeGeometry(2, 10, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(15, 1, 20);
            hlPlayer.add(mesh);

            glasses = new THREE.CubeGeometry(10, 2, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(10, -3, 20);
            hlPlayer.add(mesh);

            glasses = new THREE.CubeGeometry(2, 10, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(5, 1, 20);
            hlPlayer.add(mesh);

            glasses = new THREE.CubeGeometry(2, 10, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(-15, 1, 20);
            hlPlayer.add(mesh);

            glasses = new THREE.CubeGeometry(2, 10, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(-5, 1, 20);
            hlPlayer.add(mesh);

            glasses = new THREE.CubeGeometry(10, 2, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(10, 5, 20);
            hlPlayer.add(mesh);

            glasses = new THREE.CubeGeometry(10, 2, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(-10, -3, 20);
            hlPlayer.add(mesh);

            glasses = new THREE.CubeGeometry(10, 2, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(0, 3, 20);
            hlPlayer.add(mesh);
            hlPlayer.position.set(75, 0, 100);
            scene.add(hlPlayer);

            var boardGeo = new THREE.BoxBufferGeometry(1000, 250, 50);
            board = new THREE.Mesh(boardGeo, whiteMaterial);
            board.position.set(0, 0, 50)
            scene.add(board);
        }

        function createCube() {
            var cubeGeometry = new THREE.CubeGeometry(40, 40, 40);
            var fullstack = new THREE.TextureLoader().load('src/fullstack.png');
            var material = new THREE.MeshBasicMaterial({
                map: fullstack
            });
            player = new THREE.Mesh(cubeGeometry, material);
            scene.add(player);
            return player;
        }

        function createTammyChu() {
            var mesh;
            player = new THREE.Object3D();
            var face = new THREE.CubeGeometry(40, 40, 40);
            var faceMaterial = new THREE.MeshPhongMaterial({
                color: 0xC68642,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(face, faceMaterial);
            player.add(mesh);

            var hatBase = new THREE.CubeGeometry(60, 8, 40);
            var hatMaterial = new THREE.MeshPhongMaterial({
                color: 0x014175,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(hatBase, hatMaterial);
            mesh.position.set(10, 24, 0);
            player.add(mesh);

            var hat = new THREE.CubeGeometry(40, 20, 40);
            var hatMaterial = new THREE.MeshPhongMaterial({
                color: 0x014175,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(hat, hatMaterial);
            mesh.position.set(0, 32, 0);
            player.add(mesh);

            var eye = new THREE.CubeGeometry(10, 2, 2);
            var eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(eye, eyeMaterial);
            mesh.position.set(10, 8, 20);
            player.add(mesh);

            eye = new THREE.CubeGeometry(10, 2, 2);
            eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(eye, eyeMaterial);
            mesh.position.set(-10, 8, 20);
            player.add(mesh);

            player.position.set(0, 0, 0);
            scene.add(player);
            return player;
        }

        function createHarrison() {
            var mesh;
            player = new THREE.Object3D();
            var face = new THREE.CubeGeometry(40, 35, 40);
            var faceMaterial = new THREE.MeshPhongMaterial({
                color: 0xC68642,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(face, faceMaterial);
            mesh.position.set(0, -5, 0);
            player.add(mesh);

            var hairBase = new THREE.CubeGeometry(40, 15, 40);
            var hairMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(hairBase, hairMaterial);
            mesh.position.set(0, 20, 0);
            player.add(mesh);

            var glasses = new THREE.CubeGeometry(10, 2, 2);
            var glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(-10, 5, 20);
            player.add(mesh);

            glasses = new THREE.CubeGeometry(2, 10, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(15, 1, 20);
            player.add(mesh);

            glasses = new THREE.CubeGeometry(10, 2, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(10, -3, 20);
            player.add(mesh);

            glasses = new THREE.CubeGeometry(2, 10, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(5, 1, 20);
            player.add(mesh);

            glasses = new THREE.CubeGeometry(2, 10, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(-15, 1, 20);
            player.add(mesh);

            glasses = new THREE.CubeGeometry(2, 10, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(-5, 1, 20);
            player.add(mesh);

            glasses = new THREE.CubeGeometry(10, 2, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(10, 5, 20);
            player.add(mesh);

            glasses = new THREE.CubeGeometry(10, 2, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(-10, 3, 20);
            player.add(mesh);

            glasses = new THREE.CubeGeometry(10, 2, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(-10, -3, 20);
            player.add(mesh);

            glasses = new THREE.CubeGeometry(10, 2, 2);
            glassesMaterial = new THREE.MeshPhongMaterial({
                color: 0x212121,
                shading: THREE.FlatShading
            })
            mesh = new THREE.Mesh(glasses, glassesMaterial);
            mesh.position.set(0, 3, 20);
            player.add(mesh);

            scene.add(player);
            return player;
        }

        function createCoin(coinGeometry) {
            var mesh;
            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(200, 100, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(-250, 150, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(-100, -150, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(500, 50, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(coinGeometry, yellowMaterial);
            mesh.position.set(350, 200, 0);
            mesh.toRotateOrNot = true;
            mesh.itemType = 'coin';
            scene.add(mesh);
            items.push(mesh);
        }

        function createDisappearingShafts(geometry) {
            mesh = new THREE.Mesh(geometry, pinkMaterial);
            mesh.position.set(100, -100, 0);
            mesh.itemType = 'byeShaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, pinkMaterial);
            mesh.position.set(250, 250, 0);
            mesh.itemType = 'byeShaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, pinkMaterial);
            mesh.position.set(-250, 350, 0);
            mesh.itemType = 'byeShaft';
            scene.add(mesh);
            items.push(mesh);
        }

        function createShafts(geometry) {
            var mesh;

            mesh = new THREE.Mesh(geometry, emeraldMaterial);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);


            mesh = new THREE.Mesh(geometry, orangeMaterial);
            mesh.position.set(100, -150, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, purpleMaterial);
            mesh.position.set(150, 50, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, tangerineMaterial);
            mesh.position.set(-100, 450, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, purpleMaterial);
            mesh.position.set(-100, 400, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, orangeMaterial);
            mesh.position.set(-500, -200, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, emeraldMaterial);
            mesh.position.set(500, -350, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);

            mesh = new THREE.Mesh(geometry, greenMaterial);
            mesh.position.set(250, -50, 0);
            mesh.itemType = 'shaft';
            scene.add(mesh);
            items.push(mesh);
        }

        function createSpikes() {
            var mesh;

            var combined = new THREE.Geometry();
            var deltaX = 25;
            var deltaZ = 25;
            var x = 75;
            var z;
            var base = new THREE.BoxGeometry(100, 20, 75, 20, 20, 20);
            base.applyMatrix(new THREE.Matrix4().makeTranslation(137, 150, 12));
            combined.merge(base, base.matrix);
            for (var i = 1; i < 5; i++) {
                x += deltaX;
                z = -40;
                for (var j = 1; j < 4; j++) {
                    z += deltaZ;
                    var spike = new THREE.CylinderGeometry(0, 15, 25, 15, 1, true);
                    spike.applyMatrix(new THREE.Matrix4().makeTranslation(x, 160, z));
                    combined.merge(spike, spike.matrix);
                }
            }
            mesh = new THREE.Mesh(combined, redMaterial);
            mesh.itemType = 'spikyShaft';
            items.push(mesh);
            scene.add(mesh);

            combined = new THREE.Geometry();
            deltaX = 25;
            deltaZ = 25;
            x = 175;
            base = new THREE.BoxGeometry(100, 20, 100, 20, 20, 20);
            base.applyMatrix(new THREE.Matrix4().makeTranslation(237, -160, 12));
            combined.merge(base, base.matrix);
            for (var i = 1; i < 5; i++) {
                x += deltaX;
                z = -40;
                for (var j = 1; j < 4; j++) {
                    z += deltaZ;
                    var spike = new THREE.CylinderGeometry(0, 15, 25, 15, 1, true);
                    spike.applyMatrix(new THREE.Matrix4().makeTranslation(x, -150, z));
                    combined.merge(spike, spike.matrix);
                }
            }
            mesh = new THREE.Mesh(combined, redMaterial);
            mesh.itemType = 'spikyShaft';
            items.push(mesh);
            scene.add(mesh);
        }

        function changeItemPositionX(item, items) {
            var curOccupiedX = items.map(shaft => shaft.position.x);
            var xPositionArr = _.range(-400, 400, 100);
            item.position.x = _.sample(xPositionArr);
            //
            var noOverlap = false;
            while (!noOverlap) {
                noOverlap = true;
                for (var i = 0; i < curOccupiedX.length; i++) {
                    item.position.x = _.sample(xPositionArr)
                    var diff = Math.abs(item.position.x - curOccupiedX[i]);
                    if (diff < 190) {
                        noOverlap &= false;
                        break;
                    }
                }
            }
        }

        function changeItemPositionY(item, items) {
            var curOccupiedY = items.map(shaft => shaft.position.y);
            var yPositionArr = _.range(-350, 350, 50);
            item.position.y = _.sample(yPositionArr);
            //
            var noOverlap = false;
            while (!noOverlap) {
                noOverlap = true;
                for (var i = 0; i < curOccupiedY.length; i++) {
                    item.position.y = _.sample(yPositionArr)
                    var diff = Math.abs(item.position.y - curOccupiedY[i]);
                    if (diff < 50) {
                        noOverlap &= false;
                        break;
                    }
                }
            }
        }

        function changePosition(item, items) {
            changeItemPositionX(item, items);
            changeItemPositionY(item, items);
            item.position.y = -350;
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function getRandomBool(float) {
            return Math.random() > float;
        }

        function rotateAroundObjAxisY(coin) {
            coin.rotation.y -= rotSpeed;
        }

        function updateScoreBoard(score, bestScores, numBestScores) {
            if (bestScores.indexOf(score) === -1) {
                bestScores.splice(_.sortedIndexBy(bestScores, score, function(n) {
                    return -n
                }), 0, score);
                if (bestScores.length >= numBestScores) {
                    bestScores.splice(-1, 1);
                }
            }
        }

        function createLives(scene) {
            var x = -45;
            var barGeo, bar;
            for (var i = 0; i < 10; i++) {
                barGeo = new THREE.BoxBufferGeometry(7, 20, 20);
                barGeo = new THREE.BoxBufferGeometry(7, 20, 20);
                bar = new THREE.Mesh(barGeo, yellowDarkMaterial);
                bar.position.set(x, 180, 100);
                scene.add(bar);
                bar.visible = false;
                lives.push(bar);
                x += 10;
            }
        }

        function updateLives(numLives) {
            if (numLives <= 0) $scope.gameOver = true;
            if ($scope.gameOver || !$scope.playing) {
                for (var i = 0; i < 10; i++) {
                    lives[i].visible = false;
                }
            } else {
                for (var i = 0; i < numLives; i++) {
                    lives[i].visible = true;
                }
                for (i; i < 10; i++) {
                    lives[i].visible = false;
                }
            }
        }

        function compareWithUnitNormVec(vec, unitNormVec) {
            var compareX = vec.x === unitNormVec.x;
            var compareY = vec.y === unitNormVec.y;
            var compareZ = vec.z === unitNormVec.z;
            return [compareX, compareY, compareZ];
        }

        function animate() {

            shaftXCollisionFromLeft = false;
            shaftXCollisionFromRight = false;
            shaftYCollision = false;
            coinCollision = false;
            shaftSpeed += 0.0005;
            playerSpeed = shaftSpeed;

            if (storeBestScore) {
                updateScoreBoard($scope.score, $scope.$storage.bestScores, $scope.numBestScores)
                alreadyStoredBestScore = true;
            }

            if ($scope.gameOver) {
                scene.remove(player);
                if ($scope.scoreboard) {
                    scoreboard.visible = true;
                    gameoverObject.visible = true;
                }
                if (!alreadyStoredBestScore) {
                    screamAudio.play();
                    storeBestScore = true;
                } else {
                    storeBestScore = false;
                }
                updateLives(0);
            } else {
                updateLives($scope.lives);
            }

            if (incrementLives) {
                incrementLives = false;
                if ($scope.lives < 10) $scope.lives += 1;
                else $scope.lives = 10;
                setTimeout(function() {
                    collisionObject = {};
                }, 5000)
            }

            if (decrementLives) {
                decrementLives = false;
                if ($scope.lives > 0) $scope.lives -= 1;
                else $scope.gameOver = true;
                resetSpeed();
                setTimeout(function() {
                    collisionObject = {};
                }, 5000)
            }

            requestAnimationFrame(animate);

            // prevent shafts from falling out of the screen
            for (var i = 0; i < items.length; i++) {

                if (items[i].itemType === 'coin') rotateAroundObjAxisY(items[i]);
                if (items[i].position.y > 350 && items[i].itemType !== 'spikyShaft') {
                    changeItemPositionX(items[i], items);
                    items[i].position.y = -350;
                } else if (items[i].position.y > 500 && items[i].itemType === 'spikyShaft') {
                    items[i].position.y = -500;
                } else {
                    // check for getting coins
                    if (items[i].itemType === 'coin') {
                        if (player) {
                            if (items[i].position.distanceTo(playerClone.position) < 15) {
                                changePosition(items[i], items);
                                coinAudio.play();
                                $scope.score += 100;
                            }
                        }
                    }
                    items[i].position.y += shaftSpeed;
                }

            }

            if ($scope.playing) {
                if (playerClone.position.y < -310) {
                    $scope.gameOver = true;
                    resetSpeed()
                    scene.remove(player)
                }
                if (playerClone.position.y > 350) {
                    setTimeout(function() {
                        decrementLives = true;
                        rightCrossAudio.play();
                    }, 300)
                }

                // check for landing on shaft
                var originPoint = playerClone.position.clone();
                for (var vertexIndex = 0; vertexIndex < playerClone.geometry.vertices.length; vertexIndex++) {
                    var localVertex = playerClone.geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(playerClone.matrix);
                    var directionVector = globalVertex.sub(playerClone.position);
                    var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
                    var collisionResults = ray.intersectObjects(items);
                    if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
                        var [compareTopX, compareTopY, compareTopZ] = compareWithUnitNormVec(collisionResults[0].face.normal, topNormalVec)
                        var [compareLeftX, compareLeftY, compareLeftZ] = compareWithUnitNormVec(collisionResults[0].face.normal, leftNormalVec);
                        var [compareRightX, compareRightY, compareRightZ] = compareWithUnitNormVec(collisionResults[0].face.normal, rightNormalVec);
                        if (compareLeftX && compareLeftY && compareLeftZ) shaftXCollisionFromLeft = true;
                        if (compareRightX && compareRightY && compareRightZ) shaftXCollisionFromRight = true;
                        if (compareTopX && compareTopY && compareTopZ) {
                            shaftYCollision = true;
                            if (collisionResults[0].object.itemType === 'shaft') {
                                if (collisionObject !== collisionResults[0].object) {
                                    incrementLives = true;
                                    jumpAudio.play();
                                }
                            }
                            if (collisionResults[0].object.itemType === 'spikyShaft') {
                                if (collisionObject !== collisionResults[0].object) {
                                    decrementLives = true;
                                    rightCrossAudio.play();
                                }
                            }
                            if (collisionResults[0].object.itemType === 'byeShaft') {
                                setTimeout(function() {
                                    if (collisionResults[0]) changePosition(collisionResults[0].object, items);
                                }, 300);
                                if (collisionObject !== collisionResults[0].object) {
                                    jumpAudio.play();
                                }
                            }
                            collisionObject = collisionResults[0].object;
                        }
                    }
                }

                // player movement
                if (upKeyDown == true) player.position.y += playerSpeed;
                if (downKeyDown == true) player.position.y -= playerSpeed;
                if (leftKeyDown == true && !shaftXCollisionFromRight) {
                    if (player.children.length) player.children.forEach(function(child) {
                        child.position.x -= playerSpeed;
                    })
                    else player.position.x -= playerSpeed
                };
                if (rightKeyDown == true && !shaftXCollisionFromLeft) {
                    if (player.children.length) player.children.forEach(function(child) {
                        child.position.x += playerSpeed;
                    })
                    else player.position.x += playerSpeed;
                }
                if (shaftYCollision == true) {
                    if (player.children.length) player.children.forEach(function(child) {
                        child.position.y += playerSpeed;
                    })
                    else player.position.y += playerSpeed;
                } else {
                    if (player.children.length) player.children.forEach(function(child) {
                        child.position.y -= playerSpeed * 2;
                    })
                    else player.position.y -= playerSpeed * 2;
                }

            }

            renderer.render(scene, camera);

        }

    });
    </script>
</body>

</html>
