<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - geometry - cube</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                margin: 0px;
                background-color: #000000;
                overflow: hidden;
            }
        </style>
    </head>
    <body>

        <script src="src/three.js"></script>

        <script>

            var camera, scene, renderer;
            var mesh;

            var upKeyDown = false;
            var downKeyDown = false;
            var leftKeyDown = false;
            var rightKeyDown = false;

            var shafts = [];
            var shaftSpeed = 3;
            var shaftHeight = 20;

            var player;
            var playerSpeed = 3;
            var playerRadius = 20;

            var collision

            init();
            animate();

            function init() {
                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
                camera.position.z = 400;

                scene = new THREE.Scene();

                //================================================
                // generate boxes
                //================================================
                var texture = new THREE.TextureLoader().load( 'src/crate.gif' );
                var geometry = new THREE.BoxBufferGeometry( 100, 20, 100 );
                var material = new THREE.MeshBasicMaterial( { map: texture } );

                var radius = 500;
                var nBoxes = 8;
                for (var i = 0; i < nBoxes; i++) {
                    var mesh = new THREE.Mesh( geometry, material );
                    mesh.position.set( radius/2 - radius * Math.random(),
                                       radius/2 - radius * Math.random(),
                                       0 );
                    scene.add(mesh);
                    shafts.push(mesh);
                }

                //================================================
                // generate player (sphere)
                //================================================
                var sphereGeometry = new THREE.CubeGeometry( 20, 20, 20 );

                player = new THREE.Mesh( sphereGeometry, new THREE.MeshNormalMaterial() );
                scene.add(player);


                // event listenters

                document.addEventListener('keydown', onKeyDown, false);
                document.addEventListener('keyup', onKeyUp, false);

                window.addEventListener( 'resize', onWindowResize, false );
            }

            function onKeyDown(e) {

                switch( e.keyCode ) {

                    case 38:
                        upKeyDown = true;
                        break;
                    case 40:
                        downKeyDown = true;
                        break;
                    case 37:
                        leftKeyDown = true;
                        break;
                    case 39:
                        rightKeyDown = true;
                        break;

                }
            }

            function onKeyUp(e) {

                switch( e.keyCode ) {

                    case 38:
                        upKeyDown = false;
                        break;
                    case 40:
                        downKeyDown = false;
                        break;
                    case 37:
                        leftKeyDown = false;
                        break;
                    case 39:
                        rightKeyDown = false;
                        break;

                }
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function onCollision(shaft) {

            }

            function animate() {

                requestAnimationFrame( animate );

                collision = false;

                for (var i = 0; i < shafts.length; i++) {
                    // prevent shafts from falling out of the screen
                    if (shafts[i].position.y > 350) {
                        shafts[i].position.y = -350;
                    } else {
                        shafts[i].position.y += shaftSpeed;
                        // if ( shafts[i].position.distanceTo( player.position ) < shaftHeight + playerRadius ) {
                        //     collision = true;
                        // }
                    }
                }

                var originPoint = player.position.clone();

                for (var vertexIndex = 0; vertexIndex < player.geometry.vertices.length; vertexIndex++) {
            		var localVertex = player.geometry.vertices[vertexIndex].clone();
            		var globalVertex = localVertex.applyMatrix4( player.matrix );
            		var directionVector = globalVertex.sub( player.position );

            		var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
            		var collisionResults = ray.intersectObjects( shafts );
            		if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() )
            			collision = true;
            	}



                // player movement
                if ( upKeyDown == true ) player.position.y += playerSpeed;
                if ( downKeyDown == true ) player.position.y -= playerSpeed;
                if ( leftKeyDown == true ) player.position.x -= playerSpeed;
                if ( rightKeyDown == true ) player.position.x += playerSpeed;

                if ( collision == true ) {
                    console.log("collision")
                    player.position.y += shaftSpeed;
                } else {
                    console.log("no collision")
                    player.position.y -= playerSpeed * 2;
                }

                renderer.render( scene, camera );

            }

        </script>

    </body>
</html>
